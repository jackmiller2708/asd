#!/usr/bin/env node

/**
 * Module dependencies.
 */

const app = require('../app');
const debug = require('debug')('chatsupport-4.0:server');
const http = require('http');

// Socket.io
const socketio = require('socket.io');

// Redis Client
const redis = require('redis');

// External utils functions
const formatMessage = require('../utils/messages');
const {
  JSONParseMap,
  JSONStringifyMap
} = require('../utils/mapUtitls');

/**
 * Get port from environment and store in Express.
 */

const port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

// Redis setup
const redis_url = process.env.REDIS_URL;

if (process.env.ENVIRONMENT === 'development') {
  require('dotenv').config();
  redis_url = "redis://127.0.0.1";
}

const redisClient = redis.createClient(redis_url);


const server = http.createServer(app);
const io = socketio(server);

// Socket.io Namespaces
const adminWorkspace = io.of('/Admins');
const clientArea = io.of('/Clients');

// Constants
const clientListName = 'Clients';

// Utils functions
/**
 * Get the meeting room id string
 * @param clientId The unique id of the client.
 * @returns {string} The meeting room id.
 */
const getMeetingRoom = clientId => `Client-${clientId}`;

/**
 * Saves the message log and send the new message
 * @param from From user.
 * @param roomId The unique room identifier.
 * @param text The message text.
 */
const setMessage = (from, roomId, text) => {
  //Constants
  const meetingRoom = getMeetingRoom(roomId);
  const formattedMessage = formatMessage(text);

  // Get the message log from chat room.
  redisClient.get(meetingRoom, (err, data) => {
    if (err) console.log(err);

    // If the log exists
    if (data) {

      // Get the log
      let messageLog = JSON.parse(data);

      // Push in new message
      messageLog.push({from: from, message: formattedMessage});

      // Save the log
      redisClient.set(meetingRoom, JSON.stringify(messageLog));
    }

    // If the log is yet to be set
    else {

      // Create new log with a single new message
      let newMessageLogWithSingleMessage = [{from: from, message: formattedMessage}];

      // Save the log
      redisClient.set(meetingRoom, JSON.stringify(newMessageLogWithSingleMessage));
    }

    // Send the message to room.
    clientArea.to(meetingRoom).emit('message', {sender: from, message: formattedMessage, roomId: roomId});
    adminWorkspace.to(meetingRoom).emit('message', {sender: from, message: formattedMessage, roomId: roomId});
  });
}

const Client = require('./Models/Client');
let clientConnections = new Map();

// Admins logic ==========================================================

adminWorkspace.on('connection', socket => {
  const updateAdminList = () => {
    let adminRooms = adminWorkspace.adapter.rooms;
    let roomIds = Array.from(adminRooms.keys());
    let roomMap = new Map();

    roomIds.forEach(id => {
      roomMap.set(id, Array.from(adminRooms.get(id)));
    })

    adminWorkspace.emit('adminUpdate', JSONStringifyMap(roomMap));
  }

  adminWorkspace.emit('clientUpdate', JSONStringifyMap(clientConnections));

  //----------------------------------------------------------------
  //----------------------------------------------------------------

  // When an admin logs into the system
  socket.on('adminLoggedOn', roomId => {
    socket.join(roomId);
    updateAdminList();
  });

  // When the admin sends a message.
  socket.on('requestSent', ({to, clientId, type}) => {
    // Signal that the other receives the message
    adminWorkspace.to(to).emit('requestReceived', {from: socket.id, client: JSON.stringify(clientConnections.get(clientId)), type: type});
  });

  // When the invitation is accepted.
  socket.on('requestAccepted', ({to, clientId, type}) => {
    let purpose = type === 'forward' ?
      `to forward to the requested client ${clientId}` :
      `to join room ${getMeetingRoom(clientId)}`;

    adminWorkspace.to(to).emit('requestAccepted',{
      type: type,
      message: `Admin-${socket.id} has accepted your request ${purpose}`});

    if (type === 'forward') {
      let client = clientConnections.get(clientId);
      let meetingRoom = getMeetingRoom(clientId);

      client.getReps().forEach(rep => {
        if (rep !== to){
          adminWorkspace.to(rep).emit('requestAccepted',{
            type: type,
            message: `Admin-${socket.id} has accepted your request ${purpose}`});

        }

        adminWorkspace.sockets.get(rep).leave(meetingRoom);
      });

      client.addRep(socket.id);
    }
  });

  // When the invitation is declined.
  socket.on('requestDeclined', ({to, clientId, type}) => {
    let purpose = type === 'forward' ?
      `to forward to the requested client ${clientId}` :
      `to join room ${getMeetingRoom(clientId)}`;

    adminWorkspace.to(to).emit('requestDeclined',{
      type: type,
      message: `Admin-${socket.id} has declined your request ${purpose}`
    });
  });

  // When a client is selected from the wait list
  socket.on('clientSelected', clientEmail => {
    const meetingRoom = getMeetingRoom(clientEmail);

    let client = clientConnections.get(clientEmail);

    socket.join(meetingRoom);

    clientArea.to(client.socketId).emit('adminConnected', socket.id);
  });

  // When the admin switches clients
  socket.on('clientSwitched', newClientId => {
    const meetingRoom = getMeetingRoom(newClientId);

    redisClient.get(meetingRoom, (err, data) => {
      if (err) console.log(err);

      if (data) {
        let chatLog = JSON.parse(data);

        adminWorkspace.to(meetingRoom).emit('chatLogUpdate', chatLog);
      }
    });
  });

  // When the admin receives a message.
  socket.on('message', ({from, to, message}) => setMessage(from, to, message));

  // When an admin is disconnected.
  socket.on('disconnect', () => {
    console.log('Admin disconnected!');
    updateAdminList();
  })
});

// Admins logic ==========================================================
// Clients logic =========================================================

clientArea.on('connection', socket => {

  // When a client requests assistance
  socket.on('requestAssistance', ({username, email}) => {
    let client = new Client({
      email: email,
      socketId: socket.id,
      username: username,
    });

    clientConnections.set(client.email, client);

     // Send the updated client list to all admins.
     adminWorkspace.emit('clientUpdate', JSONStringifyMap(clientConnections));
  });

  // When an admin is connected to the conversation.
  socket.on('adminConnected', adminId => {

    clientConnections.forEach(client => {
      if (client.socketId == socket.id) {
        let meetingRoom = getMeetingRoom(client.email);

        socket.join(meetingRoom);

        client.setState("chatting");

        client.addRep(adminId);

        setMessage("Bot", client.email, `--- Admin-${adminId} is connected ---`);
      }
    });

    let stringifiedList = JSONStringifyMap(clientConnections);

    adminWorkspace.emit('clientUpdate', stringifiedList);
  });

  // When the client receives a message.
  socket.on('message', ({from, to, message}) => setMessage(from, to, message));

  // When a client is disconnected
  socket.on('disconnect', () => {
    clientConnections.forEach(client => {
      if (client.socketId == socket.id) {
        clientConnections.delete(client.email);

        const stringifiedList = JSONStringifyMap(clientConnections);

        adminWorkspace.emit('clientUpdate', stringifiedList);

        client.reps.forEach(rep => {
          adminWorkspace.to(rep).emit('clientDisconnect', client.username);
        });

        setMessage('Bot', client.email, `--- ${client.username} has left ---`);
      }
    });
  });
})

// Clients logic =========================================================

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  let port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  let bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  let addr = server.address();
  let bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
