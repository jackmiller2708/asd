#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('chatsupport5.0:server');
var http = require('http');

// Socket.io
const socketio = require('socket.io');

// Redis Client
const redis = require('redis');

const {parse, stringify} = require('flatted');

// External utils functions
const formatMessage = require('../utils/messages');
const { replacer, reviver } = require('../utils/mapUtitls');

// User Objects
const Admin = require('./Models/Admin');
const Client = require('./Models/Client');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3001');
app.set('port', port);

/**
 * Create HTTP server.
 */

 // Redis setup
const redis_url = process.env.REDIS_URL;

if (process.env.ENVIRONMENT === 'development') {
  require('dotenv').config();
  redis_url = "redis://127.0.0.1";
}

const redisClient = redis.createClient(redis_url);

var server = http.createServer(app);
const io = socketio(server);

// Socket.io Namespaces
const adminWorkspace = io.of('/Admins');
const clientArea = io.of('/Clients');

let clientConnections =  new Map(),
    adminConnections = new Map();

adminWorkspace.on('connection', socket => {
  // When an admin logs into the system
  socket.on('adminLoggedOn', adminJSON => {
    let parsedAdminObj = parse(adminJSON, reviver);
    let oldAdmin = adminConnections.get(parsedAdminObj.email);

    if (oldAdmin === undefined) {
      let admin = new Admin({
        email: parsedAdminObj.email,
        username: parsedAdminObj.username,
        socketIds: [socket.id],
        position: parsedAdminObj.position
      });

      socket.join(parsedAdminObj.position);

      adminConnections.set(admin.email, admin);
    }

    else oldAdmin.addSocketId(socket.id);

    adminWorkspace.emit('adminUpdate', stringify(adminConnections, replacer));
    adminWorkspace.emit('clientUpdate', stringify(clientConnections, replacer));
  });

  socket.on('clientSelected', clientEmail => {
    const meetingRoom = getMeetingRoom(clientEmail);

    socket.join(meetingRoom);

    let admin = getAdmin(socket.id);

    let client = clientConnections.get(clientEmail);

    if (admin.clients.some(client => client.email !== clientEmail) || admin.clients.length === 0) admin.clients.push(client);

    client.socketIds.forEach(id => clientArea.to(id).emit('adminConnected', admin.email));
  });

  socket.on('clientSwitched', newClientEmail => {
    const meetingRoom = getMeetingRoom(newClientEmail);

    redisClient.get(meetingRoom, (err, data) => {
      if (err) console.log(err);

      if (data) {
        let chatLog = JSON.parse(data);

        adminWorkspace.to(meetingRoom).emit('chatLogUpdate', chatLog);
      }
    });
  });

  socket.on('message', ({from, to, text}) => setMessage(from, to, text));

  socket.on('requestSent', ({to, clientEmail, type}) => {
    let client = clientConnections.get(clientEmail);

    let toAdmin = getAdmin(to);

    if (type === "invite") {
      if (client.reps.find(rep => rep.socketIds.includes(to)) === undefined) {
        adminWorkspace.to(to).emit('requestReceived', {
          from: stringify(getAdmin(socket.id), replacer),
          client: stringify(client, replacer),
          type: type
        });
      }

      else {
        adminWorkspace.to(socket.id).emit('requestDeclined' , {
          type: type,
          message: `Admin-${toAdmin.username} is already in chat room!`
        });
      }
    }
    else {
      adminWorkspace.to(to).emit('requestReceived', {
        from: stringify(getAdmin(socket.id), replacer),
        client: stringify(client, replacer),
        type: type
      });
    }
  });

  socket.on('requestAccepted', ({to, clientEmail, type}) => {

    let client = clientConnections.get(clientEmail);
    let meetingRoom = getMeetingRoom(clientEmail);
    let currentAdmin = getAdmin(socket.id);
    let toAdmin =  getAdmin(to);

    let purpose = type === 'forward' ?
      `to forward to the requested client (${client.username})` :
      `to join chat with Client-${client.username}`;

      toAdmin.socketIds.forEach(id => adminWorkspace.to(id).emit('requestAccepted', {
        type: type,
        message: `Admin-${currentAdmin.username} has accepted your request ${purpose}`
      }));

      if(type === 'forward') {
        client.reps.forEach(rep => {

          rep.clients.forEach(adminClient => {
            if (client.socketIds.some(id => adminClient.socketIds.includes(id))) {
              rep.clients.splice(rep.clients.findIndex(obj => obj.email === client.email), 1);
            }
          });

          rep.socketIds.forEach(id => adminWorkspace.sockets.get(id).leave(meetingRoom));
        });

        client.resetReps();
      }
  });

  socket.on('requestDeclined', ({to, clientEmail, type}) => {

    let client = clientConnections.get(clientEmail);
    let currentAdmin = getAdmin(socket.id);
    let toAdmin =  getAdmin(to);

    let purpose = type === 'forward' ?
      `to forward to the requested client (${client.username})` :
      `to join chat with Client-${client.username}`;

      toAdmin.socketIds.forEach(id => adminWorkspace.to(id).emit('requestDeclined', {
        type: type,
        message: `Admin-${currentAdmin.username} has declined your request ${purpose}`
      }));
  });


  socket.on('disconnect', () => {

    adminConnections.forEach(admin => {

      admin.getSocketIds().forEach(id => {

        if (id === socket.id) {

          admin.removeSocketId(id);

          if (admin.getSocketIds().length === 0) {

            console.log('admin disconnected');

            admin.clients.forEach(client => {

              setMessage('BOT', client.email, `--- Admin-${admin.username} has disconnected! ---`);

              client.reps.splice(client.reps.findIndex(rep => rep.socketIds.some(id => admin.socketIds.includes(id))), 1);
            })

            adminConnections.delete(admin.email);
          }

          adminWorkspace.emit('adminUpdate', stringify(adminConnections, replacer));
        }
      });
    });
  });
});

clientArea.on('connection', socket => {

  socket.on('requestAssistance', ({username, email}) => {

    let oldClient = clientConnections.get(email);

    if (oldClient !== undefined) {

      const meetingRoom = getMeetingRoom(email);

      oldClient.addSocketId(socket.id);

      socket.join(meetingRoom);

      if (oldClient.state === 'offline') oldClient.state = 'waiting';

      console.log(adminWorkspace.adapter.rooms.get(meetingRoom));

      if (adminWorkspace.adapter.rooms.get(meetingRoom) !== undefined) {

        oldClient.state = 'chatting';

        adminWorkspace.adapter.rooms.get(meetingRoom).forEach(adminId => {
          let admin = getAdmin(adminId);

          oldClient.reps.push(admin);

          clientArea.to(oldClient.getSocketIds()[0]).emit('adminConnected', admin.email);
        });

        redisClient.get(getMeetingRoom(email), (err, data) => {

          if (err) {console.log(err);}

          if (data) {

            let chatLog = JSON.parse(data);

            clientArea.to(socket.id).emit('chatLogUpdate', chatLog);
          }
        });
      }

      adminWorkspace.emit('clientUpdate', stringify(clientConnections, replacer));
    }
    else {

      let client = new Client({
        email: email,
        socketIds: [socket.id],
        username: username,
      });

      clientConnections.set(client.email, client);

      // Send the updated client list to all admins.
      adminWorkspace.emit('clientUpdate', stringify(clientConnections, replacer));
    }
  });

  socket.on('adminConnected', connectedAdminEmail => {

    let connectedAdmin = adminConnections.get(connectedAdminEmail);

    clientConnections.forEach(client => {

      if (client.getSocketIds().includes(socket.id)) {

        const meetingRoom = getMeetingRoom(client.email);

        socket.join(meetingRoom);

        const clientReps = client.getReps();

        if (clientReps.length === 0 || clientReps.find(admin => admin.email === connectedAdmin.email) === undefined) {

          if (clientReps.length === 0) client.setState("chatting");

          client.reps.push(connectedAdmin);

          setMessage("BOT", client.email, `--- Admin ${connectedAdmin.username} has connected ---`);

        }

        return;
      }
    });

    adminWorkspace.emit('clientUpdate', stringify(clientConnections, replacer));
    adminWorkspace.emit('adminUpdate', stringify(adminConnections, replacer));
  });

  socket.on('message', ({from, to, text}) => setMessage(from, to, text));

   // When a client is disconnected
   socket.on('disconnect', () => {

    clientConnections.forEach(client => {

      const clientSocketIds = client.getSocketIds();

      if (clientSocketIds.includes(socket.id)) {

        client.removeSocketId(socket.id);

        if (clientSocketIds.length === 0) {

          client.getReps().forEach(rep => {
            adminWorkspace.to(rep.socketIds[0]).emit('clientDisconnect', client.username);
          });

          client.resetReps();

          client.state = "offline";

          setMessage("BOT", client.email, `--- Client ${client.username} has disconnected ---`);

          const stringifiedList = stringify(clientConnections, replacer);

          adminWorkspace.emit('clientUpdate', stringifiedList);
        }

        return;
      }
    });
  });
})

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}


// Utitls Functions =================================================================
/**
 * Get the meeting room id string
 * @param clientId The unique id of the client.
 * @returns {string} The meeting room id.
 */
const getMeetingRoom = clientId => `Client-${clientId}`;

const setMessage = (from, roomId, text) => {
  //Constants
  const meetingRoom = getMeetingRoom(roomId);
  const formattedMessage = formatMessage(text)
  let fromUser;

  adminConnections.forEach(admin => {
    if (admin.getSocketIds().includes(from)) fromUser = admin;
  });

  if (fromUser === undefined) {
    clientConnections.forEach(client => {
      if (client.getSocketIds().includes(from)) fromUser = client;
    })
  }

  if (fromUser === undefined) fromUser = "BOT";

  redisClient.get(meetingRoom, (err, data) => {
    if (err) console.log(err);

    if (data) {
      // Get the log
      let messageLog = JSON.parse(data);

      messageLog.push({from: fromUser !== "BOT" ? fromUser.getEmail() : "BOT", message: formattedMessage});

      redisClient.set(meetingRoom, JSON.stringify(messageLog));
    }
    else {
      // Create new log with a single new message
      let newMessageLogWithSingleMessage = [{from: fromUser !== "BOT" ? fromUser.getEmail() : "BOT", message: formattedMessage}];

      redisClient.set(meetingRoom, JSON.stringify(newMessageLogWithSingleMessage));
    }

    // Send the message to room.
    clientArea.to(meetingRoom).emit('message', {sender: fromUser !== "BOT" ? fromUser.getEmail() : "BOT", message: formattedMessage, roomId: roomId});
    adminWorkspace.to(meetingRoom).emit('message', {sender: fromUser !== "BOT" ? fromUser.getEmail() : "BOT", message: formattedMessage, roomId: roomId});
  });
}

const getAdmin = socketId => {
  let currentAdmin;

  adminConnections.forEach(admin => {
    if (admin.socketIds.includes(socketId)) currentAdmin = admin
  });

  return currentAdmin;
}